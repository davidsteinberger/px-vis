<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-colors-design/colors.html"/>
<link rel="import" href="px-vis-behavior-common.html"/>

<dom-module id="px-vis-register-item">
  <link rel="import" type="css" href="css/px-vis-register.css"/>
  <template>
    <span
      class$="[[_itemMutedToStart]]"
      name$="R{{item.name}}"
      on-click="_seriesClicked">
      <span
        class="seriesMarker"
        style$="background-color:[[_itemColor]]"
        name$="R{{item.name}}">&nbsp;</span>
      <span
        class$="[[_wrapperClass]]">
        <div
          class="seriesName"
          name$="R{{item.name}}">
          {{_truncatedName}}&nbsp;
          <template is="dom-if" if="[[_didTruncate]]">
            <px-tooltip delay="500">[[_configName]]</px-tooltip>
          </template>
        </div>
        <!-- Display serie data differently depending on x and y axis types -->
        <div class="seriesData" name$="R{{item.name}}">
          <!-- if x axis is number format and show it -->
          <template is="dom-if" if="{{_isOfType(xAxisType, 'linear')}}">
            x linear
            <numbro-element
              value="[[_itemX]]"
              format="[[numberFormat]]"
              culture="[[numberFormatCulture]]"
              currency$="[[numberFormatIsCurrency]]"
              default-currency-format="[[numberFormatCurrency]]"
              zero-format="[[numberFormatZero]]">
            </numbro-element>
            <template is="dom-if" if="[[_itemX]]">
              <!-- {{_getXUnit(item, completeSeriesConfig.*)}} -->
            </template>
            <template is="dom-if" if="[[_itemX]]">
              &nbsp;/&nbsp
            </template>
          </template>
          <!-- if x axis is ordinal just display it -->
          <template is="dom-if" if="{{_isOfType(xAxisType, 'ordinal')}}">
            x ordinal
            <span>[[_itemX]]</span>
            <template is="dom-if" if="[[_itemX]]">
              <!-- {{_getXUnit(item, completeSeriesConfig.*)}} -->
            </template>
            <template is="dom-if" if="[[_itemX]]">
              &nbsp;/&nbsp
            </template>
          </template>
          <!-- if x axis is time don't display it -->
          <!-- if y axis is number format and show it -->
            <template is="dom-if" if="{{_isOfType(yAxisType, 'linear')}}">
              <numbro-element
                value="[[_itemY]]"
                format="[[numberFormat]]"
                culture="[[numberFormatCulture]]"
                currency$="[[numberFormatIsCurrency]]"
                default-currency-format="[[numberFormatCurrency]]"
                zero-format="[[numberFormatZero]]">
              </numbro-element>
            </template>
            <!-- if y axis is ordinal just display it -->
            <template is="dom-if" if="{{_isOfType(yAxisType, 'ordinal')}}">
              <span>[[_itemY]]</span>
            </template>
            <template is="dom-if" if="[[_itemY]]">
              {{_getYUnit(item, completeSeriesConfig.*)}}
            </template>
          </div>
        </span>
      </span>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-vis-register-item',
    behaviors: [
      PxVisBehavior.formatting,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehavior.truncating,
      PxVisBehavior.mutedSeries,
      PxVisBehavior.axisTypes,
      commonColors
    ],
    properties: {
      item: {
        type: Object
      },
      _itemColor: {
        type: String,
        computed: '_computeItemColor(item, completeSeriesConfig)'
      },
      _itemX: {
        type: String,
        computed: '_computeItemX(item, completeSeriesConfig)'
      },
      _itemY: {
        type: String,
        computed: '_computeItemY(item, completeSeriesConfig)'
      },
      _itemMutedToStart: {
        type: String,
        computed: '_computeItemMutedToStart(item, completeSeriesConfig)'
      },
      _truncatedName: {
        type: String,
        computed: '_computeTruncatedName(item, completeSeriesConfig)'
      },
      _didTruncate: {
        type: Boolean,
        computed: '_computeDidTruncate(item, completeSeriesConfig)'
      },
      _configName: {
        type: String,
        computed: '_computeConfigName(item, completeSeriesConfig)'
      },
      _wrapperClass: {
        type: String,
        computed: '_getWrapperClass(item, completeSeriesConfig)'
      },
      /**
       * Defines if the register should be horizontal or vertical. Options are:
       *  - `vertical`
       *  - `horizontal`
       *
       * @property type
       * @type string
       * @default vertical
      */
      type: {
       type: String,
       value: "vertical",
       notify: true
      },
    },
    _computeItemY: function() {
      return this._returnVal(this.item, 'y', '&nbsp;/&nbsp');
    },
    _computeItemX: function() {
      return this._returnVal(this.item, 'x', '&nbsp;/&nbsp');
    },
    _computeItemMutedToStart: function() {
      return this._mutedToStart(this.item.name);
    },
    _computeConfigName: function() {
      return this._getConfigName(this.item.name);
    },
    _computeTruncatedName: function() {
      return this._truncateName(this._getConfigName(this.item.name), this.truncationLength);
    },


    /**
     * helper function to set initial classes
     *
     * Adds or removes muted class to those series in the register and sets base classes.
     *
     * @method _mutedToStart
     */
    _mutedToStart: function() {
      var baseClasses = (this.type === 'horizontal') ? "series narrow flex flex--row" : "series wide flex flex--row";
      if(this.mutedSeries[this.name]) {
        return baseClasses + ' muted';
      }
      return baseClasses;
    },

    /**
     * Event function which is fired when a series is clicked.
     *
     * Adds series to mutedSeries property or toggles that key's boolean.
     *
     * @method _seriesClicked
     * @param {e} click event
     */
    _seriesClicked: function(e) {
      var ne = Polymer.dom(e),
          series = ne.rootTarget.getAttribute('name').substr(1);
      // if it doesnt exist, let's add it and set to true
      if( typeof(this.mutedSeries[series]) === 'undefined' ) {
        this.set('mutedSeries.' + series, true);
      } else {
        //if does exist, flip the bit
        this.set('mutedSeries.' + series, !this.mutedSeries[series]);
      }
      this.fire('px-vis-muted-series-updated',
        { 'data': this.mutedSeries[series],
          'dataVar': ('mutedSeries.'+series),
          'method': 'set'
        });
      e.stopPropagation();
    },

    /**
     * Function which takes an index and returns the appropriate dataVisColor
     *
     * `i` is a series index number
     *
     * `rgb(r,g,b)` return the appropriate rgb values based in the series index
     *
     * @method _returnItemColor
     * @param {i}
     * @return {rgb}
     */
    _computeItemColor: function() {
      return this.completeSeriesConfig[this.item.name]['color'];
    },

    _returnVal: function(item, axis, separator) {
      var key;
      if(axis === 'x') {
        key = this.completeSeriesConfig[item.name]['x'];
      } else {
        key = this.completeSeriesConfig[item.name]['y'];
      }
      if(item.value && item.value[key]) {
        return item.value[key] + (separator ? separator : '');
      }
      return null;
    },

    /**
     * dom-if function for series names to decide if it was truncated. If so, add a tooltip showing full name
     *
     * @method _didTruncate
     * @param {str} the original string.
     * @param {len} the truncation length.
     */
    _computeDidTruncate: function(str,len) {
      var name = this._getConfigName(this.item.name)
      var len = this.truncationLength;
      return len > 2 && name.length > len ? true : false;
    },

    _getConfigName: function(name) {
      if(this.xAxisType === 'pie') {
        //pie should have only one config bit.
        var key = Object.keys(this.completeSeriesConfig)[0];
        return name[this.completeSeriesConfig[key].y];
      } else {
        return this.completeSeriesConfig[this.item.name]['name'];
      }
    },

    _isOfType: function(toTest, type) {
      return toTest === type;
    },

    _getYUnit: function(item, completeSeriesConfig) {
      return this.completeSeriesConfig[item.name] && this.completeSeriesConfig[item.name].yAxisUnit ? this.completeSeriesConfig[item.name].yAxisUnit : '';
    },

    _getWrapperClass: function() {
      var classList = 'flex ';
      if(this.type === 'horizontal') {
        classList += 'flex--col ';
      } else {
        classList += 'flex--row flex--justify';
      }
      return classList;
    },

  });
</script>
